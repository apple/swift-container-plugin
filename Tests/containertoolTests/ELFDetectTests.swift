//===----------------------------------------------------------------------===//
//
// This source file is part of the SwiftContainerPlugin open source project
//
// Copyright (c) 2025 Apple Inc. and the SwiftContainerPlugin project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of SwiftContainerPlugin project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import Foundation
import Testing

@testable import containertool

@Suite struct ElfDetectUnitTests {
    let invalid_magic: [UInt8] = [
        0x12, 0x34, 0x4c, 0x46, 0x02, 0x01, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0xa9, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x88, 0x8a, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x09, 0x00, 0x40, 0x00, 0x32, 0x00, 0x30, 0x00,
    ]

    let invalid_version: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0xa9, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x88, 0x8a, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x09, 0x00, 0x40, 0x00, 0x32, 0x00, 0x30, 0x00,
    ]

    let invalid_length: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02,
    ]

    // x86-64 executable (64-bit, little-endian)
    let linux_x86_64: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0xa9, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x88, 0x8a, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x09, 0x00, 0x40, 0x00, 0x32, 0x00, 0x30, 0x00,
    ]

    // AArch64 executable (64-bit, little-endian)
    let linux_aarch64: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0xb7, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe0, 0x90, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x8a, 0x82, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x09, 0x00, 0x40, 0x00, 0x32, 0x00, 0x30, 0x00,
    ]

    // AArch64 core (64-bit, little-endian)
    let linux_aarch64_core: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x04, 0x00, 0xb7, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe0, 0x90, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x8a, 0x82, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x09, 0x00, 0x40, 0x00, 0x32, 0x00, 0x30, 0x00,
    ]

    // AArch64 os-specific (64-bit, little-endian)
    let linux_aarch64_os_specific: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xfe, 0xb7, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe0, 0x90, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x8a, 0x82, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x09, 0x00, 0x40, 0x00, 0x32, 0x00, 0x30, 0x00,
    ]

    // PowerPC64 is one of the small number of practical current big endian architectures.

    // PowerPC64 executable (64-bit, big-endian)
    let linux_ppc64: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x15, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x31, 0xd0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x00, 0x38, 0x00, 0x06, 0x00, 0x40, 0x00, 0x17, 0x00, 0x14,
    ]

    // PowerPC64le executable (64-bit, little-endian)
    let linux_ppc64le: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x15, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x50, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x06, 0x00, 0x40, 0x00, 0x17, 0x00, 0x14, 0x00,
    ]

    // MIPS64 is not a current Swift build target but can be used to test handling of unknown ISAs.

    // MIPS64 executable (64-bit, big-endian)
    let linux_mips64: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x3f, 0x58,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90,
        0x20, 0x00, 0x00, 0x04, 0x00, 0x40, 0x00, 0x38, 0x00, 0x06, 0x00, 0x40, 0x00, 0x17, 0x00, 0x14,
    ]

    // MIPS64le executable (64-bit, little-endian)
    let linux_mips64le: [UInt8] = [
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x3b, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x20, 0x40, 0x00, 0x38, 0x00, 0x06, 0x00, 0x40, 0x00, 0x17, 0x00, 0x14, 0x00,
    ]

    @Test func testReadInvalidMagic() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(invalid_magic.count == 0x40)

        #expect(ELF.read(invalid_magic) == nil)
    }

    @Test func testReadInvalidVersion() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(invalid_version.count == 0x40)

        #expect(ELF.read(invalid_version) == nil)
    }

    @Test func testReadInvalidLength() async throws {
        #expect(ELF.read(invalid_length) == nil)
    }

    @Test func testReadLinuxX86_64() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(linux_x86_64.count == 0x40)

        // Compare to values from readelf
        let header = try #require(ELF.read(linux_x86_64))
        let expected = ELF(
            encoding: .bits64,
            endianness: .littleEndian,
            ABI: .SysV,
            object: .executable,
            ISA: .x86_64
        )
        #expect(header == expected)
    }

    @Test func testReadLinuxAarch64() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(linux_aarch64.count == 0x40)

        // Compare to values from readelf
        let header = try #require(ELF.read(linux_aarch64))
        let expected = ELF(
            encoding: .bits64,
            endianness: .littleEndian,
            ABI: .SysV,
            object: .executable,
            ISA: .aarch64
        )
        #expect(header == expected)
    }

    @Test func testReadLinuxAarch64Core() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(linux_aarch64_core.count == 0x40)

        // Compare to values from readelf
        let header = try #require(ELF.read(linux_aarch64_core))
        let expected = ELF(
            encoding: .bits64,
            endianness: .littleEndian,
            ABI: .SysV,
            object: .core,
            ISA: .aarch64
        )
        #expect(header == expected)
    }

    @Test func testReadLinuxAarch64OSSpecific() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(linux_aarch64_os_specific.count == 0x40)

        // Compare to values from readelf
        let header = try #require(ELF.read(linux_aarch64_os_specific))
        let expected = ELF(
            encoding: .bits64,
            endianness: .littleEndian,
            ABI: .SysV,
            object: .reservedOS(0xfeff),  // Upper bound of OS-specific range
            ISA: .aarch64
        )
        #expect(header == expected)
    }

    @Test func testReadLinuxPPC64() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(linux_ppc64.count == 0x40)

        // Compare to values from readelf
        let header = try #require(ELF.read(linux_ppc64))
        let expected = ELF(
            encoding: .bits64,
            endianness: .bigEndian,
            ABI: .SysV,
            object: .executable,
            ISA: .powerpc64
        )
        #expect(header == expected)
    }

    @Test func testReadLinuxPPC64le() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(linux_ppc64le.count == 0x40)

        // Compare to values from readelf
        let header = try #require(ELF.read(linux_ppc64le))
        let expected = ELF(
            encoding: .bits64,
            endianness: .littleEndian,
            ABI: .SysV,
            object: .executable,
            ISA: .powerpc64
        )
        #expect(header == expected)
    }

    @Test func testReadLinuxMips64() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(linux_mips64.count == 0x40)

        // Compare to values from readelf
        let header = try #require(ELF.read(linux_mips64))
        let expected = ELF(
            encoding: .bits64,
            endianness: .bigEndian,
            ABI: .SysV,
            object: .executable,
            ISA: .unknown(0x0008)  // MIPS
        )
        #expect(header == expected)
    }

    @Test func testReadLinuxMips64le() async throws {
        // Verify test data: 64-bit ELF headers should be 64 bytes long
        #expect(linux_mips64le.count == 0x40)

        // Compare to values from readelf
        let header = try #require(ELF.read(linux_mips64le))
        let expected = ELF(
            encoding: .bits64,
            endianness: .littleEndian,
            ABI: .SysV,
            object: .executable,
            ISA: .unknown(0x0008)  // MIPS
        )
        #expect(header == expected)
    }
}
